from typing import Any
import requests
from langchain.llms.huggingface_endpoint import HuggingFaceEndpoint

query_context_split: str = '|'

class HuggingFaceQAEndpoint(HuggingFaceEndpoint):
    base_url: str = "https://api-inference.huggingface.co/models/"
    task: str = 'question-answering'
    query_context_split: str = query_context_split
    repo_id: str

    def _call(
        self,
        prompt: str,
        **kwargs: Any,
    ) -> str:
        """
        Call out to HuggingFace Hub's inference endpoint for a question answering type model

        Args:
            prompt: The prompt to pass into the model.
                    Needs to contain a query and context, separated by the query_context_split string

        Returns:
            The string generated by the model.
        """
        _model_kwargs = self.model_kwargs or {}

        question = context = None
        try:
            question, context = prompt.split(self.query_context_split)
        except:
            raise ValueError(
                f"Prompt for BERT-type model must contain the query/context separator {self.query_context_split}"
            )
        
        # payload
        params = {**_model_kwargs, **kwargs}
        parameter_payload = {
            "question": question,
		    "context": context, 
            "parameters": params}

        # HTTP headers for authorization
        headers = {
            "Authorization": f"Bearer {self.huggingfacehub_api_token}",
            "Content-Type": "application/json",
        }

        # send request
        try:
            response = requests.post(
                self.base_url + self.repo_id, headers=headers, json=parameter_payload
            )
        except requests.exceptions.RequestException as e:  # This is the correct syntax
            raise ValueError(f"Error raised by inference endpoint: {e}")
        
        generated_text = response.json()
        if "error" in generated_text:
            raise ValueError(
                f"Error raised by inference API: {generated_text['error']}"
            )

        text = generated_text["answer"]
        return text